package subcmd

import (
	"context"
	"flag"
	"fmt"
	"net"
	"os"

	"github.com/julienschmidt/httprouter"
	"github.com/mengelbart/mrtp/cmdmain"
	"github.com/mengelbart/mrtp/flags"
	"github.com/mengelbart/mrtp/gstreamer"
	"github.com/mengelbart/mrtp/internal/http"
	"github.com/mengelbart/mrtp/webrtc"
)

var (
	localPort      string
	remotePort     string
	offer          bool
	pionCCFB       bool
	pionTWCC       bool
	pionReports    bool
	pionNACK       bool
	pionReadCCFB   bool
	sendVideoTrack bool
)

func init() {
	cmdmain.RegisterSubCmd("webrtc", func() cmdmain.SubCmd { return new(WebRTC) })
}

type WebRTCCodecParameters struct {
	MimeType    string
	ClockRate   uint32
	PayloadType uint8
}

var WebRTCExtraCodecs = []WebRTCCodecParameters{}

type WebRTC struct{}

// Help implements cmdmain.SubCmd.
func (w *WebRTC) Help() string {
	return "Run webrtc peer"
}

func (w *WebRTC) Exec(cmd string, args []string) error {
	fs := flag.NewFlagSet("webrtc", flag.ExitOnError)
	flags.RegisterInto(fs, []flags.FlagName{
		flags.LocalAddrFlag,
		flags.RemoteAddrFlag,
		flags.GstCCFBFlag,
		flags.TraceRTPRecvFlag,
		flags.TraceRTPSendFlag,
		flags.CCgccFlag,
		flags.CCnadaFlag,
		flags.MaxTragetRateFlag,
	}...)
	fs.StringVar(&localPort, "local-port", "8080", "Local port of HTTP signaling server to listen on")
	fs.StringVar(&remotePort, "remote-port", "8080", "Remote Port of HTTP signaling server to connect to")

	fs.BoolVar(&offer, "offer", false, "Act as the offerer for WebRTC signaling")
	fs.BoolVar(&pionCCFB, "pion-ccfb", false, "Send RTCP CCFB packets generated by Pion")
	fs.BoolVar(&pionTWCC, "pion-twcc", false, "Send RTCP TWCC packets generated by Pion")
	fs.BoolVar(&pionReports, "pion-reports", false, "Send RTCP SR/RR packets generated by Pion")
	fs.BoolVar(&pionNACK, "pion-nack", false, "Send RTCP NACK packets generated by Pion")
	fs.BoolVar(&pionReadCCFB, "pion-read-ccfb", false, "Let Pion read incoming CCFB reports")
	fs.BoolVar(&sendVideoTrack, "send-track", false, "Send a media track to the peer")

	DefaultStreamSinkFactory.ConfigureFlags(fs)
	DefaultStreamSourceFactory.ConfigureFlags(fs)

	fs.Usage = func() {
		fmt.Fprintf(os.Stderr, `Run a WebRTC pipeline

Usage:
	%v webrtc [flags]
`, cmd)
		fs.PrintDefaults()
		fmt.Fprintln(os.Stderr)
	}
	fs.Parse(args)

	pipeline, err := gstreamer.NewRTPBin()
	if err != nil {
		return err
	}

	signaler := webrtc.NewHTTPClientSignaler(fmt.Sprintf("http://%v:%v", flags.RemoteAddr, remotePort))

	stdnet, err := webrtc.NewNet(webrtc.SetRecvBufferSize(10_000_000)) // 10MB
	if err != nil {
		return err
	}
	webrtcOptions := []webrtc.Option{
		webrtc.SetNet(stdnet),
		webrtc.SetSRTPBufferLimit(10_000_000), // 10MB
		webrtc.RegisterDefaultCodecs(),
		webrtc.OnTrack(func(receiver *webrtc.RTPReceiver) {
			sink, newSinkErr := DefaultStreamSinkFactory.MakeStreamSink("rtp-stream-sink", int(receiver.PayloadType()))
			if newSinkErr != nil {
				panic(err)
			}
			if pipelineErr := pipeline.AddRTPSink(0, sink); pipelineErr != nil {
				panic(pipelineErr)
			}
			if pipelineErr := pipeline.ReceiveRTPStreamFrom(0, receiver, flags.GstCCFB); pipelineErr != nil {
				panic(pipelineErr)
			}
			if pipelineErr := pipeline.ReceiveRTCPFrom(receiver.RTCPReceiver()); pipelineErr != nil {
				panic(pipelineErr)
			}
		}),
	}

	if pionCCFB {
		webrtcOptions = append(webrtcOptions, webrtc.EnableCCFB())
	}
	if pionTWCC {
		webrtcOptions = append(webrtcOptions, webrtc.EnableTWCC())
	}
	if pionNACK {
		webrtcOptions = append(webrtcOptions, webrtc.EnableNACK())
	}
	if pionReports {
		webrtcOptions = append(webrtcOptions, webrtc.EnableRTCPReports())
	}
	if pionReadCCFB {
		webrtcOptions = append(webrtcOptions, webrtc.EnableCCFBReceiver())
	}
	if flags.CCgcc {
		webrtcOptions = append(webrtcOptions, webrtc.EnableGCC(750_000, 150_000, int(flags.MaxTargetRate)))
	}
	if flags.CCnada {
		webrtcOptions = append(webrtcOptions, webrtc.EnableNADA(750_000, 150_000, flags.MaxTargetRate))
	}
	if flags.TraceRTPRecv {
		webrtcOptions = append(webrtcOptions, webrtc.EnableRTPRecvTraceLogging())
	}
	if flags.TraceRTPSend {
		webrtcOptions = append(webrtcOptions, webrtc.EnableRTPSendTraceLogging())
	}

	connectedCtx, cancelConnectedCtx := context.WithCancel(context.Background())
	webrtcOptions = append(webrtcOptions, webrtc.OnConnected(func() {
		cancelConnectedCtx()
	}))

	if len(WebRTCExtraCodecs) > 0 {
		for _, c := range WebRTCExtraCodecs {
			webrtcOptions = append(webrtcOptions, webrtc.AddExtraCodecs(c.MimeType, c.ClockRate, c.PayloadType))
		}
	}

	transport, err := webrtc.NewTransport(
		signaler,
		offer,
		webrtcOptions...,
	)
	if err != nil {
		return err
	}
	signalingHandler := webrtc.NewHTTPSignalingHandler(transport)
	router := httprouter.New()
	router.HandlerFunc("POST", "/candidate", signalingHandler.HandleCandidate)
	router.HandlerFunc("POST", "/session_description", signalingHandler.HandleSessionDescription)

	host := net.JoinHostPort(flags.LocalAddr, localPort)
	s, err := http.NewServer(
		http.H1Address(host),
		http.ListenH2(false),
		http.ListenH3(false),
		http.RedirectH1ToH3(false),
		http.Handle(router),
	)
	if err != nil {
		return err
	}
	go s.ListenAndServe()

	if sendVideoTrack {
		var source gstreamer.RTPSourceBin
		source, err = DefaultStreamSourceFactory.MakeStreamSource("rtp-stream-source")
		if err != nil {
			return err
		}

		var rtpSink *webrtc.RTPSender
		rtpSink, err = transport.AddLocalTrackWithCodec(source.EncodingName())
		if err != nil {
			return err
		}
		if err = pipeline.AddRTPTransportSink(0, rtpSink); err != nil {
			return err
		}

		// set callback of transport, so CCs can set the target rate of the encoder
		ba, ok := source.(BitrateAdapter)
		if ok {
			transport.SetTargetRate = ba.SetBitrate
		}

		// TODO(ME): Cannot enable SCReAM here because WebRTC rewrites the SSRCs
		// of outgoing packets. Thus, the sender cannot use the feedback,
		// because the receiver will mirror the SSRC set by Pion and not the one
		// seen by the ScreamTx implementation.
		// Another problem in the current ScreamRx implementation is that it
		// does not correctly set the CCFB type (count value of the RTCP
		// header). Pion expects the correct type, otherwise it can't forward
		// the packet to the correct SSRC (because it cannot read the media SSRC
		// from a raw RTCP packet. The ScreamTx sender on the other hand,
		// expects the type set to 0.
		if err = pipeline.AddRTPSourceStreamGst(0, source); err != nil {
			return err
		}
		if err = pipeline.ReceiveRTCPFrom(rtpSink.RTCPReceiver()); err != nil {
			return err
		}
	} else {
		if err = transport.AddRemoteVideoTrack(); err != nil {
			return err
		}
	}

	if err = pipeline.SendRTCPForStream(0, transport); err != nil {
		return err
	}

	<-connectedCtx.Done()
	return pipeline.Run()
}
