package subcmd

import (
	"errors"
	"flag"
	"fmt"
	"net"
	"os"

	"github.com/julienschmidt/httprouter"
	"github.com/mengelbart/mrtp/gstreamer"
	"github.com/mengelbart/mrtp/internal/http"
	"github.com/mengelbart/mrtp/webrtc"
)

type webrtcFlags struct {
	localAddr      string
	localPort      string
	remoteAddr     string
	remotePort     string
	sendVideoFile  string
	offer          bool
	sendVideoTrack bool
	gstCCFB        bool
	pionCCFB       bool
	pionTWCC       bool
	pionReports    bool
	pionNACK       bool
	pionReadCCFB   bool
	pionGCC        bool
	nada           bool
}

func WebRTC(cmd string, args []string) error {
	var wf webrtcFlags
	flags := flag.NewFlagSet("webrtc", flag.ExitOnError)

	flags.StringVar(&wf.localAddr, "local-address", "localhost", "Local address of HTTP signaling server to listen on")
	flags.StringVar(&wf.localPort, "local-port", "8080", "Local port of HTTP signaling server to listen on")
	flags.StringVar(&wf.remoteAddr, "remote-addr", "localhost", "Remote address of HTTP signaling server to connect to")
	flags.StringVar(&wf.remotePort, "remote-port", "8080", "Remote Port of HTTP signaling server to connect to")
	flags.StringVar(&wf.sendVideoFile, "file", "videotestsrc", "Which video to send")
	flags.BoolVar(&wf.offer, "offer", false, "Act as the offerer for WebRTC signaling")
	flags.BoolVar(&wf.sendVideoTrack, "send-track", false, "Send a media track to the peer")
	flags.BoolVar(&wf.gstCCFB, "gst-ccfb", false, "Send CCFB RTCP Feedback packets generated by the screamrx Gstreamer element")
	flags.BoolVar(&wf.pionCCFB, "pion-ccfb", false, "Send RTCP CCFB packets generated by Pion")
	flags.BoolVar(&wf.pionTWCC, "pion-twcc", false, "Send RTCP TWCC packets generated by Pion")
	flags.BoolVar(&wf.pionReports, "pion-reports", false, "Send RTCP SR/RR packets generated by Pion")
	flags.BoolVar(&wf.pionNACK, "pion-nack", false, "Send RTCP NACK packets generated by Pion")
	flags.BoolVar(&wf.pionReadCCFB, "pion-read-ccfb", false, "Let Pion read incoming CCFB reports")
	flags.BoolVar(&wf.pionGCC, "pion-gcc", false, "Run Pion GCC")
	flags.BoolVar(&wf.nada, "nada", false, "Run NADA")

	flags.Usage = func() {
		fmt.Fprintf(os.Stderr, `Run a WebRTC pipeline

Usage:
	%v webrtc [flags]
`, cmd)
		flags.PrintDefaults()
		fmt.Fprintln(os.Stderr)
	}
	flags.Parse(args)

	pipeline, err := gstreamer.NewRTPBin()
	if err != nil {
		return err
	}

	signaler := webrtc.NewHTTPClientSignaler(fmt.Sprintf("http://%v:%v", wf.remoteAddr, wf.remotePort))

	webrtcOptions := []webrtc.Option{
		webrtc.OnTrack(func(receiver *webrtc.RTPReceiver) {
			sink, newSinkErr := gstreamer.NewStreamSink("rtp-stream-sink", gstreamer.StreamSinkPayloadType(int(receiver.PayloadType())))
			if newSinkErr != nil {
				panic(err)
			}
			if pipelineErr := pipeline.AddRTPReceiveStreamSinkGst(0, sink); pipelineErr != nil {
				panic(pipelineErr)
			}
			if pipelineErr := pipeline.ReceiveRTPStreamFrom(0, receiver, wf.gstCCFB); pipelineErr != nil {
				panic(pipelineErr)
			}
			if pipelineErr := pipeline.ReceiveRTCPFrom(receiver.RTCPReceiver()); pipelineErr != nil {
				panic(pipelineErr)
			}
		}),
	}

	if wf.pionCCFB {
		webrtcOptions = append(webrtcOptions, webrtc.EnableCCFB())
	}
	if wf.pionTWCC {
		webrtcOptions = append(webrtcOptions, webrtc.EnableTWCC())
	}
	if wf.pionNACK {
		webrtcOptions = append(webrtcOptions, webrtc.EnableNACK())
	}
	if wf.pionReports {
		webrtcOptions = append(webrtcOptions, webrtc.EnableRTCPReports())
	}
	if wf.pionReadCCFB {
		webrtcOptions = append(webrtcOptions, webrtc.EnableCCFBReceiver())
	}
	if wf.pionGCC {
		webrtcOptions = append(webrtcOptions, webrtc.EnableGCC(100_000, 10_000, 1_000_000))
	}
	if wf.nada {
		webrtcOptions = append(webrtcOptions, webrtc.EnableNADA(1_000, 100, 1_000_000))
	}

	transport, err := webrtc.NewTransport(
		signaler,
		wf.offer,
		webrtcOptions...,
	)
	if err != nil {
		return err
	}
	signalingHandler := webrtc.NewHTTPSignalingHandler(transport)
	router := httprouter.New()
	router.HandlerFunc("POST", "/candidate", signalingHandler.HandleCandidate)
	router.HandlerFunc("POST", "/session_description", signalingHandler.HandleSessionDescription)

	host := net.JoinHostPort(wf.localAddr, wf.localPort)
	s, err := http.NewServer(
		http.H1Address(host),
		http.ListenH2(false),
		http.ListenH3(false),
		http.RedirectH1ToH3(false),
		http.Handle(router),
	)
	if err != nil {
		return err
	}
	go s.ListenAndServe()

	if wf.sendVideoTrack {
		var rtpSink *webrtc.RTPSender
		rtpSink, err = transport.AddLocalTrack()
		if err != nil {
			return err
		}
		if err = pipeline.AddRTPTransportSink(0, rtpSink); err != nil {
			return err
		}
		streamSourceOpts := make([]gstreamer.StreamSourceOption, 0)
		if wf.sendVideoFile != "videotestsrc" {
			// check if file exists
			if _, err := os.Stat(wf.sendVideoFile); errors.Is(err, os.ErrNotExist) {
				return fmt.Errorf("file does not exist: %v", wf.sendVideoFile)
			}

			streamSourceOpts = append(streamSourceOpts, gstreamer.StreamSourceFileSourceLocation(wf.sendVideoFile))
			streamSourceOpts = append(streamSourceOpts, gstreamer.StreamSourceType(gstreamer.Filesrc))
		}

		var source *gstreamer.StreamSource
		source, err = gstreamer.NewStreamSource("rtp-stream-source", streamSourceOpts...)
		if err != nil {
			return err
		}

		// set callback of transport, so CCs can set the target rate of the encoder
		transport.SetTargetRate = source.SetBitrate

		// TODO(ME): Cannot enable SCReAM here because WebRTC rewrites the SSRCs
		// of outgoing packets. Thus, the sender cannot use the feedback,
		// because the receiver will mirror the SSRC set by Pion and not the one
		// seen by the ScreamTx implementation.
		// Another problem in the current ScreamRx implementation is that it
		// does not correctly set the CCFB type (count value of the RTCP
		// header). Pion expects the correct type, otherwise it can't forward
		// the packet to the correct SSRC (because it cannot read the media SSRC
		// from a raw RTCP packet. The ScreamTx sender on the other hand,
		// expects the type set to 0.
		if err = pipeline.AddRTPSourceStreamGst(0, source.Element(), false); err != nil {
			return err
		}
		if err = pipeline.ReceiveRTCPFrom(rtpSink.RTCPReceiver()); err != nil {
			return err
		}
	} else {
		if err = transport.AddRemoteVideoTrack(); err != nil {
			return err
		}
	}

	if err = pipeline.SendRTCPForStream(0, transport); err != nil {
		return err
	}

	return pipeline.Run()
}
