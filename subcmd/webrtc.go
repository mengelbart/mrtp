package subcmd

import (
	"context"
	"errors"
	"flag"
	"fmt"
	"net"
	"os"

	"github.com/julienschmidt/httprouter"
	"github.com/mengelbart/mrtp/cmdmain"
	"github.com/mengelbart/mrtp/flags"
	"github.com/mengelbart/mrtp/gstreamer"
	"github.com/mengelbart/mrtp/internal/http"
	"github.com/mengelbart/mrtp/logging"
	"github.com/mengelbart/mrtp/webrtc"
)

var (
	localPort      string
	remotePort     string
	offer          bool
	pionCCFB       bool
	pionTWCC       bool
	pionReports    bool
	pionNACK       bool
	pionReadCCFB   bool
	pionGCC        bool
	pionNADA       bool
	sendVideoTrack bool
)

func init() {
	cmdmain.RegisterSubCmd("webrtc", func() cmdmain.SubCmd { return new(WebRTC) })
}

type WebRTC struct{}

// Help implements cmdmain.SubCmd.
func (w *WebRTC) Help() string {
	return "Run webrtc peer"
}

func (w *WebRTC) Exec(cmd string, args []string) error {
	fs := flag.NewFlagSet("webrtc", flag.ExitOnError)
	flags.RegisterInto(fs, []flags.FlagName{
		flags.LocalAddrFlag,
		flags.RemoteAddrFlag,
		flags.SendVideoFileFlag,
		flags.GstCCFBFlag,
		flags.SinkTypeFlag,
		flags.LocationFlag,
		flags.LogFileFlag,
		flags.TraceRTPRecvFlag,
		flags.TraceRTPSendFlag,
	}...)
	fs.StringVar(&localPort, "local-port", "8080", "Local port of HTTP signaling server to listen on")
	fs.StringVar(&remotePort, "remote-port", "8080", "Remote Port of HTTP signaling server to connect to")

	fs.BoolVar(&offer, "offer", false, "Act as the offerer for WebRTC signaling")
	fs.BoolVar(&pionCCFB, "pion-ccfb", false, "Send RTCP CCFB packets generated by Pion")
	fs.BoolVar(&pionTWCC, "pion-twcc", false, "Send RTCP TWCC packets generated by Pion")
	fs.BoolVar(&pionReports, "pion-reports", false, "Send RTCP SR/RR packets generated by Pion")
	fs.BoolVar(&pionNACK, "pion-nack", false, "Send RTCP NACK packets generated by Pion")
	fs.BoolVar(&pionReadCCFB, "pion-read-ccfb", false, "Let Pion read incoming CCFB reports")
	fs.BoolVar(&pionGCC, "pion-gcc", false, "Run Pion GCC")
	fs.BoolVar(&pionNADA, "nada", false, "Run NADA")
	fs.BoolVar(&sendVideoTrack, "send-track", false, "Send a media track to the peer")

	fs.Usage = func() {
		fmt.Fprintf(os.Stderr, `Run a WebRTC pipeline

Usage:
	%v webrtc [flags]
`, cmd)
		fs.PrintDefaults()
		fmt.Fprintln(os.Stderr)
	}
	fs.Parse(args)

	// use log file
	if flags.LogFile != "" {
		f, err := os.Create(flags.LogFile)
		if err != nil {
			panic(err)
		}
		defer f.Close()

		logging.UseFileForLogging(f)
	}

	pipeline, err := gstreamer.NewRTPBin()
	if err != nil {
		return err
	}

	signaler := webrtc.NewHTTPClientSignaler(fmt.Sprintf("http://%v:%v", flags.RemoteAddr, remotePort))

	webrtcOptions := []webrtc.Option{
		webrtc.OnTrack(func(receiver *webrtc.RTPReceiver) {
			sink, newSinkErr := gstreamer.NewStreamSink(
				"rtp-stream-sink",
				gstreamer.StreamSinkPayloadType(int(receiver.PayloadType())),
				gstreamer.StreamSinkType(gstreamer.SinkType(flags.SinkType)),
				gstreamer.StreamSinkLocation(flags.Location),
			)
			if newSinkErr != nil {
				panic(err)
			}
			if pipelineErr := pipeline.AddRTPSink(0, sink); pipelineErr != nil {
				panic(pipelineErr)
			}
			if pipelineErr := pipeline.ReceiveRTPStreamFrom(0, receiver, flags.GstCCFB); pipelineErr != nil {
				panic(pipelineErr)
			}
			if pipelineErr := pipeline.ReceiveRTCPFrom(receiver.RTCPReceiver()); pipelineErr != nil {
				panic(pipelineErr)
			}
		}),
	}

	if pionCCFB {
		webrtcOptions = append(webrtcOptions, webrtc.EnableCCFB())
	}
	if pionTWCC {
		webrtcOptions = append(webrtcOptions, webrtc.EnableTWCC())
	}
	if pionNACK {
		webrtcOptions = append(webrtcOptions, webrtc.EnableNACK())
	}
	if pionReports {
		webrtcOptions = append(webrtcOptions, webrtc.EnableRTCPReports())
	}
	if pionReadCCFB {
		webrtcOptions = append(webrtcOptions, webrtc.EnableCCFBReceiver())
	}
	if pionGCC {
		webrtcOptions = append(webrtcOptions, webrtc.EnableGCC(750_000, 150_000, 3_000_000))
	}
	if pionNADA {
		webrtcOptions = append(webrtcOptions, webrtc.EnableNADA(750_000, 150_000, 3_000_000))
	}
	if flags.TraceRTPRecv {
		webrtcOptions = append(webrtcOptions, webrtc.EnableRTPRecvTraceLogging())
	}
	if flags.TraceRTPSend {
		webrtcOptions = append(webrtcOptions, webrtc.EnableRTPSendTraceLogging())
	}

	connectedCtx, cancelConnectedCtx := context.WithCancel(context.Background())
	webrtcOptions = append(webrtcOptions, webrtc.OnConnected(func() {
		cancelConnectedCtx()
	}))

	transport, err := webrtc.NewTransport(
		signaler,
		offer,
		webrtcOptions...,
	)
	if err != nil {
		return err
	}
	signalingHandler := webrtc.NewHTTPSignalingHandler(transport)
	router := httprouter.New()
	router.HandlerFunc("POST", "/candidate", signalingHandler.HandleCandidate)
	router.HandlerFunc("POST", "/session_description", signalingHandler.HandleSessionDescription)

	host := net.JoinHostPort(flags.LocalAddr, localPort)
	s, err := http.NewServer(
		http.H1Address(host),
		http.ListenH2(false),
		http.ListenH3(false),
		http.RedirectH1ToH3(false),
		http.Handle(router),
	)
	if err != nil {
		return err
	}
	go s.ListenAndServe()

	if sendVideoTrack {
		var rtpSink *webrtc.RTPSender
		rtpSink, err = transport.AddLocalTrack()
		if err != nil {
			return err
		}
		if err = pipeline.AddRTPTransportSink(0, rtpSink); err != nil {
			return err
		}
		streamSourceOpts := make([]gstreamer.StreamSourceOption, 0)
		if flags.SendVideoFile != "videotestsrc" {
			// check if file exists
			if _, err := os.Stat(flags.SendVideoFile); errors.Is(err, os.ErrNotExist) {
				return fmt.Errorf("file does not exist: %v", flags.SendVideoFile)
			}

			streamSourceOpts = append(streamSourceOpts, gstreamer.StreamSourceFileSourceLocation(flags.SendVideoFile))
			streamSourceOpts = append(streamSourceOpts, gstreamer.StreamSourceType(gstreamer.Filesrc))
		}

		var source *gstreamer.StreamSource
		source, err = gstreamer.NewStreamSource("rtp-stream-source", streamSourceOpts...)
		if err != nil {
			return err
		}

		// set callback of transport, so CCs can set the target rate of the encoder
		transport.SetTargetRate = source.SetBitrate

		// TODO(ME): Cannot enable SCReAM here because WebRTC rewrites the SSRCs
		// of outgoing packets. Thus, the sender cannot use the feedback,
		// because the receiver will mirror the SSRC set by Pion and not the one
		// seen by the ScreamTx implementation.
		// Another problem in the current ScreamRx implementation is that it
		// does not correctly set the CCFB type (count value of the RTCP
		// header). Pion expects the correct type, otherwise it can't forward
		// the packet to the correct SSRC (because it cannot read the media SSRC
		// from a raw RTCP packet. The ScreamTx sender on the other hand,
		// expects the type set to 0.
		if err = pipeline.AddRTPSourceStreamGst(0, source, false); err != nil {
			return err
		}
		if err = pipeline.ReceiveRTCPFrom(rtpSink.RTCPReceiver()); err != nil {
			return err
		}
	} else {
		if err = transport.AddRemoteVideoTrack(); err != nil {
			return err
		}
	}

	if err = pipeline.SendRTCPForStream(0, transport); err != nil {
		return err
	}

	<-connectedCtx.Done()
	return pipeline.Run()
}
